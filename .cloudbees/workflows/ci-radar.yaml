apiVersion: automation.cloudbees.io/v1alpha1
kind: workflow
name: "CI Radar — HTML to MinIO (ngrok)"

on:
  workflow_dispatch:
    inputs:
      jenkins_controller:
        description: "Jenkins Controller to analyze (or 'list' to see available controllers)"
        type: string
        required: true
        default: "list"
      jenkins_credentials:
        description: "Jenkins credentials to use"
        type: choice
        options:
          - "jenkins-prod-creds"
          - "jenkins-staging-creds"
          - "jenkins-dev-creds"
        default: "jenkins-prod-creds"
      language:
        description: "Report language"
        type: choice
        options: ["en", "fr"]
        default: "en"
      prompt:
        description: "Optional custom prompt"
        type: string
        required: false

jobs:
  build:
    env:
      AWS_DEFAULT_REGION: "us-east-1"
      AWS_S3_FORCE_PATH_STYLE: "true"

    steps:
      - name: Checkout
        uses: cloudbees-io/checkout@v1

      - name: List Available Controllers or Configure Environment
        uses: docker://alpine:latest
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          JENKINS_USERNAME: ${{ secrets[format('{0}_USERNAME', inputs.jenkins_credentials)] }}
          JENKINS_TOKEN: ${{ secrets[format('{0}_TOKEN', inputs.jenkins_credentials)] }}
          CLOUDBEES_API_TOKEN: ${{ secrets.CLOUDBEES_API_TOKEN }}
        run: |
          set -euo pipefail
          
          # Si l'utilisateur a tapé "list", afficher les contrôleurs disponibles
          if [[ "${{ inputs.jenkins_controller }}" == "list" ]]; then
            echo "=== AVAILABLE JENKINS CONTROLLERS ==="
            echo ""
            
            # Récupérer la liste des contrôleurs via l'API CloudBees
            # Adapter selon votre setup CloudBees CI Operations Center
            curl -s -H "Authorization: Bearer $CLOUDBEES_API_TOKEN" \
                 -H "Accept: application/json" \
                 "https://your-operations-center.cloudbees.com/cjoc/api/json?tree=computer[displayName,url]" | \
            jq -r '.computer[] | select(.displayName != "master") | "- \(.displayName): \(.url)"' || {
              echo "Could not fetch controllers list. Available controllers:"
              echo "- controller-1.cloudbees.com"
              echo "- controller-2.cloudbees.com" 
              echo "- controller-3.cloudbees.com"
            }
            
            echo ""
            echo "Please re-run this workflow with one of the controller names above."
            echo "Example: controller-1.cloudbees.com"
            exit 0
          fi
          
          # Sinon, continuer avec la configuration normale
          echo "Configuring environment for controller: ${{ inputs.jenkins_controller }}"
          
          # Construire l'URL Jenkins
          if [[ "${{ inputs.jenkins_controller }}" =~ ^https?:// ]]; then
            JENKINS_URL="${{ inputs.jenkins_controller }}"
          else
            JENKINS_URL="https://${{ inputs.jenkins_controller }}"
          fi
          
          # Create .env file
          cat > .env << EOF
          # Jenkins Configuration
          JENKINS_URL=$JENKINS_URL
          JENKINS_USERNAME=$JENKINS_USERNAME
          JENKINS_TOKEN=$JENKINS_TOKEN
          
          # AI Configuration
          OPENAI_API_KEY=$OPENAI_API_KEY
          AI_MODEL=gpt-4
          EOF
          
          echo "Environment configured successfully"
          echo "Jenkins URL: $JENKINS_URL"

      - name: Install deps
        # Skip si on liste seulement les contrôleurs
        if: ${{ inputs.jenkins_controller != 'list' }}
        uses: docker://python:3.11
        shell: bash
        run: |
          set -euo pipefail
          python -V
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run CI Radar (HTML)
        if: ${{ inputs.jenkins_controller != 'list' }}
        id: run
        uses: docker://python:3.11
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p outputs
          
          # Build arguments array
          args=(--format html --language "${{ inputs.language }}")
          
          # Smart prompt selection
          if [[ -n "${{ inputs.prompt }}" ]]; then
            args+=(--prompt "${{ inputs.prompt }}")
          else
            if [[ "${{ inputs.language }}" == "fr" ]]; then
              args+=(--prompt "prompts/prompt_expert_fr.txt")
            else
              args+=(--prompt "prompts/prompt_expert_en.txt")
            fi
          fi
          
          echo "Running: python main.py ${args[@]}"
          python main.py "${args[@]}"

          REPORT_FILE=$(ls -1 outputs/*.html | head -n1 || true)
          [[ -z "$REPORT_FILE" ]] && { echo "No HTML report found in outputs/"; exit 1; }

          echo "report-path=$REPORT_FILE" >> "$CLOUDBEES_OUTPUTS"

      # ... reste du workflow identique